---
title: Multi-factor Authentication and Resource Owner Password
description: How to use Multi-factor Authentication with Resource Owner Password Grant.
toc: true
topics:
  - api-authentication
  - oidc
  - mfa
  - resource-owner-password
contentType: tutorial
useCase:
  - secure-api
  - call-api
---
# Multi-factor Authentication and the Resource Owner Password Grant

<%= include('../_includes/_ropg-warning') %>

Highly-trusted applications can use the [Resource Owner Password Grant](/api-auth/grant/password) to access an API. The flow typically involves prompting the user for username and password as credentials to be submitted to Auth0. In some scenarios, however, stronger authentication may be required. This document outlines using <dfn data-key="multifactor-authentication">multi-factor authentication (MFA)</dfn> with the [Resource Owner Password Grant](/api-auth/grant/password).

## Prerequisites

Before you continue, make sure that you've met the following prerequisites:

1. MFA is enabled on the [Auth0 dashboard](${manage_url}). [Duo Security](/multifactor-authentication/factors/duo) is __not__ supported as a factor with this flow.

1. An Application is configured to execute the Resource Owner Password Grant (either [password](/api-auth/tutorials/password-grant) or [password-realm](/api-auth/tutorials/password-grant#realm-support) grant types). For details on how to implement this, refer to [Execute the Resource Owner Password Grant](/api-auth/tutorials/password-grant).

1. End users are enrolled in MFA.

## Initiate Multi-factor Authentication

The flow starts by collecting end-user credentials and sending them to Auth0, as described in [Resource Owner Password Grant](/api-auth/grant/password). Both [password](/api-auth/tutorials/password-grant) and [password-realm](/api-auth/tutorials/password-grant#realm-support) flows are available.

1. The user enters their credentials into the Application.

2. The Application forwards the credentials to Auth0.

3. Auth0 validates the credentials and executes any applicable [rules](/rules).

4. If any rule triggers MFA for the current user, an error code of `mfa_required` is returned. The error will additionally contain an `mfa_token` property.

  ```json
  HTTP/1.1 403 Forbidden
  Content-Type: application/json
  {
    "error": "mfa_required",
    "error_description": "Multi-factor authentication required",
    "mfa_token": "eyJ0eXAiOiJKV1QiLCJhbGci....D3QCiQ"
  }
  ```

5. The Application will then make a request to the [MFA challenge](/api/authentication#resource-owner-password-and-mfa) endpoint, specifying the challenge types it supports. Valid challenge types are: [OTP](#challenge-type-otp), [OOB with binding method `prompt`](#challenge-type-oob-and-binding-method-prompt), and [OOB with no binding method](#challenge-type-oob-with-no-binding-method). If you already know that `otp` is supported by the end-user and you don't want to request a different factor, you can skip this and the next steps an go directly to [Challenge Type `OTP`](#challenge-type-otp) below.

6. Auth0 sends a response containing the `challenge_type` derived from the types supported by the Application and the specific user. Additionally, extra information, such as `binding_method` may be included to assist in resolving the challenge and displaying the correct UI to the user.

The supported challenge types are:

- `otp`: A one-time password generated by an app setup with a seed or by token generation hardware. This mechanism does not require an extra channel to prove possession; you can get it directly from the app / hardware device.

- `oob`: The proof of possession is done 'out of band' via a side channel. There are several different channels, including push notification-based authenticators and SMS-based authenticators. Depending on the channel and the authenticator chosen at enrollment, you may need to provide a `binding_code` used to bind the side channel and the channel used for authentication.

To execute MFA, follow the next steps according to the challenge type you will use:

- [OTP](#challenge-type-otp): for this challenge type, your application must prompt the end-user for an OTP code and continue the flow using the __mfa-otp__ grant type.

- [OOB and binding method `prompt`](#challenge-type-oob-and-binding-method-prompt): the challenge will be sent through a side channel (such as SMS), and your application will need to prompt the user for the `binding_code` that was included as part of the challenge sent, as well as the `oob_code` received as response to this request to prove possession.

- [OOB with no binding method](#challenge-type-oob-with-no-binding-method): in this case, the proof of possession will be driven entirely in a side channel (such as a push notification-based authenticator). The response will include an `oob_code` that the Application will use to periodically check for the resolution of the transaction. Continue the flow using the __mfa-oob__ grant type.

## Execute Multi-factor Authentication

The following sections cover how to execute MFA based on the challenge type used.

### Challenge Type: `OTP`

![Resource Owner MFA OTP](/media/articles/api-auth/challenge-type-otp.png)

For this type of challenge, the Application must get an one-time password (`otp`) code from a OTP Generator app, such as Google Authenticator or Microsoft Authenticator.

::: note
If you already know that the user supports OTP, then steps 5 and 6 above of the [Initiate Multi-factor Authentication](#initiate-multifactor-authentication) section are optional.
:::

7. The Application prompts the end user to enter an OTP code.

8. The end user enters their OTP into the Application.

9. The Application forwards the OTP code to Auth0 using [grant_type=http://auth0.com/oauth/grant-type/mfa-otp](/api/authentication#resource-owner-password) and includes the `mfa_token` obtained in step 4 above.

10. Auth0 validates the provided OTP and returns the Access Token and the <dfn data-key="refresh-token">Refresh Token</dfn>.

11. The Application can use the Access Token to call the API on behalf of the end user.

### Challenge Type: `OOB` with Binding Method `prompt`

![Resource Owner MFA OOB Prompt](/media/articles/api-auth/challenge-type-oob-with-binding-method.png)

This challenge type, together with `prompt` binding method, indicates that the challenge will be delivered to the user using a side channel (such as SMS) and that a `binding_code` is needed to bind the side channel to the one being authenticated. The binding code is sent as part of the challenge message and it is usually an OTP-like code composed of 6 numeric digits.

7. The Application prompts the user for the `binding_code` and stores the `oob_code` from step 6 for future use.

8. The end user receives the challenge on the side channel and enters the `binding_code` into the Application.

9. The Application forwards the `binding_code` to Auth0 using [grant_type=http://auth0.com/oauth/grant-type/mfa-oob](/api/authentication#resource-owner-password) and includes the `mfa_token` (from step 4) and `oob_code` (from step 6).

10. Auth0 validates the `binding_code` and `oob_code` and returns the Access Token and the Refresh Token.

11. The Application can use the Access Token to call the API on behalf of the end user.

### Challenge Type: `OOB` with No Binding Method

![Resource Owner MFA OOB](/media/articles/api-auth/challenge-type-oob-no-binding-method.png)

In this scenario, the challenge will be sent using a side channel, however, there is no need for a `binding_code`. Currently, the only mechanism supported for this scenario is Push Notification with the Guardian Provider.

7. The Application asks the user to accept the delivered challenge and keeps the `oob_code` from step 6 for future use.

8. The Application polls Auth0 using [grant_type=http://auth0.com/oauth/grant-type/mfa-oob](/api/authentication#resource-owner-password) and includes the `mfa_token` (from step 4) and `oob_code` (from step 6).

9. Auth0 validates the provided `oob_code`, the `mfa_token` and returns:
    - `authorization_pending` error: if the challenge has not been accepted nor rejected.
    - `slow_down` error: if the polling is too frequent.
    - an `access_token` and a `refresh_token`: if the challenge has been accepted; polling should be stopped at this point.
    - `invalid_grant` error: if the challenge has been rejected; polling should be stopped at this point.

10. The Application can use the Access Token to call the API on behalf of the end user.

## Using Recovery Codes

::: note
This flow is not available when the user uses provider = `google-authenticator` or provider = `duo`.
:::

![Resource Owner MFA Recovery](/media/articles/api-auth/recovery-code.png)

Some providers support using a recovery code to login in case the enrolled device is not available, or if lack of connectivity prevents receiving an OTP code or push notification.

Using a recovery code is similar to using an OTP code to login. The main difference is that a new recovery code will be generated, and that the application must display this new recovery code to the user for secure storage.

Steps 1-4 are the same as above.

5. End user chooses to use the recovery code.

6. The Application prompts the end user to enter recovery code.

7. The end user enters their recovery code into the Application.

8. The Application forwards the recovery code to Auth0 using [grant_type=http://auth0.com/oauth/grant-type/mfa-otp](/api/authentication#resource-owner-password) and includes the `mfa_token` from step 4.

9. Auth0 validates the recovery code and returns the Access Token and the Refresh Token.

10. The Application can use the Access Token to call the API on behalf of the end user.

## Samples

The following are sample implementations involving MFA.

### Resource Owner Password Grant Request

```javascript
var request = require("request");

var options = { method: 'POST',
  url: 'https://${account.namespace}/oauth/token',
  headers: { 'content-type': 'application/x-www-form-urlencoded' },
  form:
   { grant_type: 'password',
     username: 'USERNAME',
     password: 'PASSWORD',
     audience: 'API_IDENTIFIER',
     scope: 'SCOPE',
     client_id: '${account.clientId}',
     client_secret: 'YOUR_CLIENT_SECRET' }
  };

request(options, function (error, response, body) {
  if (error) throw new Error(error);

  if (body.error === 'mfa_required') {
    // Show mfa flow and give user option to go to the recovery flow (if supported)

    if (/* MFA Recovery is requested*/) {
      const recovery_code = // Prompt for recovery code
      mfaRecovery(body.mfa_token, recovery_code) // See MFA Recovery grant
    } else {
      mfaChallenge(body.mfa_token)
    }
  }
});
```

### Challenge Request

```javascript
function mfaChallenge(mfa_token) {
  var options = { method: 'POST',
    url: 'https://${account.namespace}/mfa/challenge',
    headers: { 'content-type': 'application/json' },
    body:
    { mfa_token: mfa_token,
      challenge_type: 'oob otp', // Supported challenge types, space separated
      client_id: '${account.clientId}',
      client_secret: 'YOUR_CLIENT_SECRET' },
    json: true };

  request(options, function (error, response, body) {
    if (error) throw new Error(error);

    if (body.challenge_type === 'otp') {
      const otp = // Prompt for otp code (see MFA OTP grant request)
      mfaOTP(mfa_token, otp)
    } else if (body.challenge_type === 'oob') {
      if (body.binding_method === 'prompt') {
        const binding_code = // Prompt for binding code (see MFA OOB with binding code grant request)
        mfaOOB(mfa_token, body.oob_code, binding_code)
      } else if (!body.binding_method) {
        // Ask the user to accept the challenge and start polling (see MFA OOB without binding code grant request)
        mfaOOB(mfa_token, body.oob_code)
      } else {
        console.error('Unsupported binding_method');
      }
    } else {
      console.error('Something went wrong');
    }
  });
}
```

### MFA OTP Grant Request

```javascript
function mfaOTP(mfa_token, otp) {
  var options = { method: 'POST',
    url: 'https://${account.namespace}/oauth/token',
    headers: { 'content-type': 'application/x-www-form-urlencoded' },
    form:
    { mfa_token: mfa_token,
      otp: otp,
      grant_type: 'http://auth0.com/oauth/grant-type/mfa-otp',
      client_id: '${account.clientId}',
      client_secret: 'YOUR_CLIENT_SECRET' }
  };

  request(options, function (error, response, body) {
    if (error) throw new Error(error);

    if (response.statusCode === 200) {
      // The tokens returned depend on the scopes requested on the password grant request
      console.log(body.access_token, body.id_token, body.refresh_token);
    } else if (body.error === 'invalid_grant') {
      // Invalid otp code
      console.error('Invalid otp');
    } else {
      console.error('Something went wrong');
    }
  });
}
```

### MFA OOB Grant Request

```javascript
function mfaOOB(mfa_token, oob_code, /* optional */ binding_code) {
  makeOOBGrantRequest(mfa_token, oob_code, binding_code, function(error, result) {
    if (error) { throw error; }

    if (result.state === 'authorization_pending') {
      // Poll every 10 seconds
      setTimeout(() => makeOOBGrantRequest(mfa_token, oob_code, binding_code), 10000);
    } else if (result.state === 'authorized')  {
      console.log(result.body.access_token, result.body.id_token, result.body.refresh_token);
    } else {
      console.error('You are not authorized')
    }
  });
}

function makeOOBGrantRequest(mfa_token, oob_code, /* optional  */ binding_code, cb) {
  var options = { method: 'POST',
    url: 'https://${account.namespace}/oauth/token',
    headers: { 'content-type': 'application/x-www-form-urlencoded' },
    form:
    { mfa_token: mfa_token,
      oob_code: oob_code,
      binding_code: binding_code, // Only when binding_method = prompt
      grant_type: 'http://auth0.com/oauth/grant-type/mfa-oob',
      client_id: '${account.clientId}',
      client_secret: 'YOUR_CLIENT_SECRET' }
    };

  request(options, function (error, response, body) {
    if (error) { return cb(error); }

    if (response.statusCode === 200) {
      // The tokens returned depend on the scopes requested on the password grant request
      cb(null, { state: 'authorized', body });
    } else if (body.error === 'invalid_grant') {
      // Invalid otp code
      cb(null, { state: 'not_authorized' });
    } else if (body.error === 'authorization_pending') {
      cb(null, { state: 'authorization_pending' });
    } else if (body.error === 'slow_down') {
      // You are polling too fast, slow down the polling rate,
      // You may want to check rate-limiting headers to manage your polling rate
      setTimeout(() => cb({ state: 'authorization_pending' }), 20000);
    } else {
      cb(new Error('Something went wrong'))
    }
  });
}
```

### MFA Recovery Grant Request

```javascript
function mfaRecovery(mfa_token, recovery_code) {
  var options = { method: 'POST',
    url: 'https://${account.namespace}/oauth/token',
    headers: { 'content-type': 'application/x-www-form-urlencoded' },
    form:
    { mfa_token: mfa_token,
      recovery_code: recovery_code,
      grant_type: 'http://auth0.com/oauth/grant-type/mfa-recovery-code',
      client_id: '${account.clientId}',
      client_secret: 'YOUR_CLIENT_SECRET' }
    };

  request(options, function (error, response, body) {
    if (error) throw new Error(error);

    if (response.statusCode === 200) {
      console.log('Please store this new recovery code safely -- the previous code will no longer work.', body.recovery_code)

      // The tokens returned depend on the scopes requested on the password grant request
      console.log(body.access_token, body.id_token, body.refresh_token);
    } else if (body.error === 'invalid_grant') {
      // Invalid recovery code
      console.error('Invalid recovery_code');
    } else {
      console.error('Something went wrong');
    }
  });
}
```

## MFA API

Please see the [MFA API section](/multifactor-authentication/api) for detailed information on Auth0's MFA API endpoints.
